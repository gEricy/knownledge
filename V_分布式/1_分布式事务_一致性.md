# 分布式事务

- 网络是产生分布式事务的根本原因

# 1. 基础概念

## 1.1. 什么是事务

在计算机系统中，更多的是通过关系型数据库来控制事务，之前已经讲过SQL数据库，它具有ACID特性。在此不再详述。

## 1.1. 本地事务

事务的运行在本地的单机环境下，不需要跨网络执行

## 1.2. 分布式事务

### 1.2.1. 分布式事务产生的背景

① 单机系统中，访问多个数据库实例（单服务访问多个数据库实例）

“用户数据库”、“订单数据库”分别存储在两个MySQL数据库中，用户管理系统删除用户信息，需要删除用户订单信息，由于数据分布在不同的数据实例，需要通过不用的数据库连接去操作数据，此时产生分布式事务。

② 多服务访问同一个数据库实例

③ 典型的场景就是微服务架构：微服务架构中通过远程调用RPC完成事务

先介绍下**微服务**：随着业务的不断扩展，为了保证系统的可扩展性，通常会将单体系统转换为多机的微服务架构，即把每个模块都拆解/模块化，形成一个个的服务。这样的一个个服务模块一般部署在不同的机器上，服务与服务之间采用<u>网络远程协作</u>配合完成工作。

再介绍**分布式事务**：即分布式系统环境下，由不同的服务之间通过网络协作完成的事务。

### 1.2.2. 分布式事务数据不一致问题

通过对比分布式事务/本机事务，说明分布式事务数据不一致问题的原因。

```c
begin transaction
    // 1. 本地数据库操作：张三减少金额
    // 2. 本地数据库操作：李四增加金额
end transaction
```

```c
begin transaction
    // 1. 本地数据库操作：张三减少金额
    // 2. 远程调用：李四增加金额
end transaction
```

分析：本地事务，通过数据库提供的事务，就可以保证安全；分布式事务，当执行完步骤1后，再执行远程调用让李四增加金额成功了，<u>可能会由于网络原因</u>，远程调用没返回，此时本地事务提交失败就回滚了张三减少金额的操作，最终造成李四（远端）和张三（本地）数据不一致了。

因此，在分布式系统中，传统的事务就失效了/无法使用了，它是由于网络问题导致的。

# 2. 分布式事务基础理论CAP

场景：分布式云存储，存在master/slaver节点，数据会写入主节点、从从节点读取数据，实现读写分离。从数据库要不断的将数据同步到和主数据库保持一致，以致于用户读到的数据是正确的。

## 2.1. CAP理论

CAP：Consistency、Availability、Partition tolerance，分别表示（一致性、可用性、分区容忍性）。

---

Consistency：在同一个时刻，分布式系统中所有节点数据一定相同。

Availability：任何请求都可以得到响应，且不会出现响应超时。

Partition tolerance：网络分区容忍性（它是分布式系统具备的基本能力）。分布式系统都分布在多个子网络，每个子网络就叫做一个区partition。分区容错性指：当区间通信失败时，仍然可以对外提供服务。

---

结论：CAP是分布式系统中才有的概念，CAP三要素，最多只能同时满足两点，不可能三者都兼顾。

① 由于个人具有分布式云存储开发经验，所以，对分布式事务有一定的理解。在分布式存储中，CAP是最常讨论的话题了。CAP三者不能同时兼得，上面已经说过，<u>分区容忍性是分布式系统具备的基本能力</u>，**在满足P的前提下，C和A存在矛盾性**。但云存储本身要求，客户端数据是基线，<u>一定要保证数据一致性</u>，这样就要保证“强PC”，会牺牲A可用性。

② 而，如果牺牲了可用性，会导致系统响应很慢，导致用户体验感极差，衡量可用性最常见的标准是几个9，6个9表示1年允许停机时间1min。

③ 要实现6个9，实际上的思路是：<u>保证AP，放弃强一致性C，保证最终一致性C</u>。

> 强一致性
>
> > 系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值；
>
> 弱一致性
>
> > 系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。但经过“不一致时间窗口”这段时间后，后续对该数据的读取都是更新后的值
> >
> > 注：最终一致性就是弱一致性的一种

## 2.2. BASE理论

上面提到，实现6个9的思路，引出了概念“强一致性”、“最终一致性”。

<u>再谈CAP，在满足P的前提下，C和A存在矛盾性</u>：① CAP的强一致性要求，在任何时刻，查询每个节点的数据都是一致的。但是这样会导致，如果存在10个节点，当前1个节点死掉，为了保证数据强一致性，那么另外的9个节点则不能提供服务，系统就不可用了！这显然是不符合系统设计要求的。② 但是，如果不保证数据一致性，那么，错误的数据一定是不可容忍的，即：我们存了100w，别人给少存了，那谁都会不开心。

### 2.2.1. 最终一致性

允许在某个时间内，每个节点的数据不一致，但是经过一段时间后，每个节点的数据必须达到一致，这就是最终数据一致性。

### 2.2.2. BASE

BASE：Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）。

*<u>基本可用</u>*：`分布式系统故障时，允许损失部分功能，保证核心功能可用`。如，电商网站交易付款出现问题了，商品仍然可以正常浏览。

<u>*软状态*</u>：如，微信支付时，先经过“支付中状态”、“数据同步中状态”，待数据最终一致后，状态改为“支付成功”或“支付失败”。

<u>*最终一致性*</u>：经过一段时间后，所有节点数据都达成一致。如，微信支付，支付状态会最终变为“支付成功”或“支付失败”中的某一个。

BASE理论是对CAP中AP的扩展，通过*<u>牺牲强一致性来获取高可用性</u>*。当出现故障时，允许部分不可用，但是要保证核心功能可用，允许数据在一段时间内是不一致的，但是最终会达到一致性状态。

# 3. 分布式事务解决方案

## 3.1.（两阶段提交） 2PC

### 3.1.1. 引出背景

为什么会引出2PC？

答：①在分布式系统中，一个节点只能知道该节点上操作执行成功or失败，不能知道其他节点操作执行情况。而分布式事务，需要所有节点上的操作全部完成才算完成，一个失败都会失败。②为了得到所有节点上操作的完成情况，引出了一个协调者（事务管理者），它用于收集各个节点上每个操作的执行情况。③最终，根据执行情况来决定事务的发展方向（成功/失败）。

---

### 3.1.2. 原理

2PC，顾名思义：将整个事务分成2个阶段，准备阶段（Prepare）、提交阶段（Commit）。它包含两个身份：协调者（事务管理者）、参与者（事务执行者）

*<u>准备阶段</u>*：协调者向每个参与者发送Prepare消息，每个数据库参与者在本地执行事务（此时锁定资源），并**写本地的Undo/Redo日志，此时事务没有提交**。

<u>*提交阶段*</u>：（提交/回滚阶段）协调者收到参与者执行失败/成功时，根据情况（**所有成功才成功，一个失败就失败**），向每个参与者发送（回滚/提交）消息。参与者根据协调者发送的指令，执行操作，执行回滚/提交后，释放锁资源。

缺点：单协调者点故障、存在数据不一致问题（当发送commit给各个节点时，可能某个节点由于网络故障没收到commit，就会导致数据不一致）、阻塞。

- 应用场景
  - 数据库XA协议
  - Seata

## 3.2. （三阶段提交）3PC

### 3.2.1. 背景

为什么引出三阶段提交？

答：因为两阶段提交，协调者发送Prepare消息后，各个节点的参与者将会锁住资源<u>直接</u>执行事务指令。但是，各个节点的事务执行成功失败的概率在难以预料的前提下就直接执行，缺点是，如果大概率执行失败的事务，你仍让他执行了，那会浪费资源。===> 三阶段提交正是解决这种问题而出现的，它会对某个分布式事务先采集/询问每个节点能不能执行，然后再根据情况下决定是否下发执行指令。

所以，可以看出，三阶段提交实际上是将二阶段提交的阶段1（Prepare），分为了2个步骤。

### 3.2.2. 原理

询问阶段：协调者先询问每个节点上的参与者是否能执行事务，等待参与者返回OK/NOT OK。

预准备阶段：收集各个参与者的返回值情况，①当参与者全部返回OK，发送事务提交信号，参与者执行事务②有一个参与者NOT OK，就不发送提交信号，中断该事件。

提交阶段：同二阶段提交的提交阶段

## 3.3. TCC（Try+Confirm+Cancle）

先说结论：TCC本质上是应用层面的2PC，需要业务逻辑来实现。TCC又称之为两阶段补偿型。

---

Try预处理：请求多个业务方**预留业务资源**，即完成所有业务检查，预留业务资源。==> 【补充】Try阶段所有的分支事务执行成功后，才执行Confirm。

Confirm：只要try成功，confirm一定成功（重试or人工介入）

Cancle：只要一个try失败，就全部回滚，Cancle一定成功（重试or人工介入）

备注：① 可以看到，TCC是针对于业务（应用层面）的，而2PC是针对于多数据库实例的。② 默认Confirm/Cancle一定会成功。若执行失败，则需要重试or人工介入。

- TCC要注意3种异常处理
  1. 空回滚：没有调用try，但调用了cancle（解决：try执行后，添加日志；cancle执行前，查看是否有日志，来决定是否执行cancle）
  2. 幂等：同一语句，无论执行多少次，结果都相同（解决：增加执行标记，每次执行前都查询标记，若标记存在，则不再执行）
  3. 悬挂：cancle比try先执行，即，try超时，TM通知执行cancle之后，try之后却预留资源成功，导致这份资源没人使用。（解决：若第2阶段执行完，则第1阶段不再继续执行）

### 3.4. 可靠消息最终一致性

前面介绍的2PC、3PC，没有根本解决性能问题。可以通过MQ的事务消息进行异步解耦，并实现系统的数据的最终一致性的话。设计可以参考文章《分布式事务之如何基于RocketMQ的事务消息特性实现分布式系统的最终一致性》

**定义**

① 事务发起方执行完成本地事务后，会发出一条消息

② 事务参与方（消息消费者）一定能接收到该消息并处理该事务成功

**解决方案**

① 本地消息表方案

② RocketMQ实现了完整的事务消息

# 一致性算法

一般应用于分布式框架中，主从节点保持数据一致性。涉及的过程：选主机制、数据同步

基本思想：选主算法都涉及到过半原则、选举原则、原子随机时常定时器、探测乒乓包; 数据同步采用2PC

- paxos

- raft

- zab