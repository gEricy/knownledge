### 2PC在SQL主从复制的应用

主从复制：2PC+redo log+binlog

1. prepare阶段： 引擎将数据，先写redo log
2. commit阶段： 再由执行器写binlog，最后执行器调用引擎的事务提交，把之前写完的redo log改成commit阶段，此时，一次事务更新操作完成

---





:sweat_smile: [主从复制的2种方式](https://blog.csdn.net/keil_wang/article/details/88669587)


**异步复制**：主服务器写完Binlog，不等同步给从服务器，就返回

**半同步复制**：主服务器写完Binlog，等待（同步）给任意一台从服务器，再返回

---

### 异步复制

- <u>主库执行操作后，写入Binlog日志后，就返回客户端</u>，这一动作就结束了，并不会验证从库有没有收到。（会存在主从数据不一致的情况）

> 在SQL中，有sync_binlog=n参数，表示每进行n次事务提交，SQL就将Binlog刷新到磁盘。如果该值设为1，就算数据库宕机了，最多只损失一次失误提交。

> 但是sync_binlog=1有以下缺点：①每次事务提交都要刷盘，影响数据库性能 ②SQL只能按照顺序来处理这些请求

异步复制的缺陷：主库提交事务写入Binlog后，当从库没有从主库得到Binlog时，由于主库宕机或磁盘损坏可能导致该事务的Binlog丢失了，那么从库就不会得到这个事务，也就造成了主从数据的不一致。

### 全同步复制

- 当主库执行完一个事务，所有从库都执行了该事务才返回给客户端。

因为需要等待所有从库执行完事务才能返回，所以全同步复制的性能必然受到严重的影响。（绝对的零丢失数据，不过性能就差的远了）

### 半同步复制

> 介于异步复制、全同步复制之间

- 当主库每次提交一个事务后，不会立即返回，而是：<u>等待其中一个从库接收到Binlog并成功写入RelayLog</u>，才返回客户端。

==> 这样，保证了一个事务至少有2份日志（一份保存在主库的Binlog，另一份保存在其中的一个从库的Relay-Log中），但是也存在隐患。

- 半同步复制的**隐患**
  - 在一主多从的场景下，因为只有一个从节点同步了主节点的数据，其他从节点没有同步主节点的数据 ==> 就会出现，主从数据不一致的情况。

针对上面的潜在问题，MySQL5.7引入了一种新的半同步方案：Loss-Less半同步复制。

### Loss-Less半同步复制



