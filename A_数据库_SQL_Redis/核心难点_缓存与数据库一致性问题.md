写在最前，在开发中，经常会在数据库之前添加一层缓存，这个地方存在一个天坑，缓存一致性问题，是先写数据库还是先写缓存，还是其他？:cry: 即便是高级的开发工程师，也可能会在这里栽跟头，因此，要引起足够的重视。

---

缓存实际上是用空间换时间的解决方案，将SQL数据库中的内容，保存到内存的缓存中，这就类似于两份相同的数据（SQL是master，缓存是slaver）。因为，在主库和备库之间同步数据，数据一致性问题是不可避免的，所以，缓存与数据库一致性问题也是不可避免的。

---

# 1. 缓存3大问题

先介绍，最简单的查询数据代码写法（单机/无并发）

```python
查询缓存
if 命中缓存:
	return 数据

查询数据库
if 在数据库中查询失败:
	return 查询失败
else:
	将查询到的数据写入缓存
	return 数据
```

## 1.1. 缓存击穿

**缓存击穿**：指数据库中有，但缓存中没有的数据。

- （一般是由于缓存时间到期），此时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库读取数据，造成数据库挂掉

**解决方案**

- 设置热点数据永远不过期
- 分布式锁
  - 先对该商品加上锁，使得其他请求不能进来
  - 然后将key写入缓存中
  - 其他后来的请求就能从缓存中找到该key

---

## 1.2. 缓存穿透

- **基本知识**：正确情况下，如果数据未在数据库中，那么该数据一定也不会出现在缓存中。

- **缓存穿透**：指数据库和缓存中都没有的数据，而用户不断发起请求（比如，发起ID=-1的请求）。一般都是恶意用户的请求攻击。

- **解决方案**：布隆过滤器

  布隆过滤器算法的特点 ① 不在布隆过滤器中的元素，一定不存在 ② 在布隆过滤器中的元素，大概率存在（但是不是“一定存在”）

- **步骤**

  - 数据库启动时，先将数据库中所有的数据，保存到布隆过滤器中
  - 当查询时，先查询布隆过滤器。如果查找失败，则直接返回；如果查找成功，则，先 查缓存，在查数据库



查询数据代码写法（单机/无并发）

```c
if (!bloomFIlter.isExist(id)) { // bloomFIlter解决缓存穿透
    return 查询失败
}

查询缓存
if 命中缓存:
	return 数据

查询数据库
if 在数据库中查询失败:
	return 查询失败
else: // 在数据库查询成功
	将查询到的数据写入缓存
	return 数据
```

查询数据代码写法（高并发+[分布式锁](https://github.com/gEricy/knownledge/blob/master/X_%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md)）

```python
if (!bloomFIlter.isExist(id)) { // bloomFIlter解决缓存穿透
    return 查询失败
}

查询缓存			      // 第一次查缓存
if 命中缓存:
	return 数据

LOCK(分布式锁)         +
{
    查询缓存		   +  // 第二次查缓存? 为什么要第二次?
    if 命中缓存:       +  // 详细见下
        return 数据   +

    查询数据库
    if 在数据库中查询失败:
        return 查询失败
    else:
        将查询到的数据写入缓存
        return 数据
}
UNLOCK(分布式锁)       +
```

解析：为什么上面的代码要查询两次缓存（锁内/锁外）？

答：两次的用途不一样。

① 第一次：就是查询数据库之前，先查一次缓存，没别的意图

② 第二次：因为加了分布式锁，在同一个时刻只能有1个线程进入临界区。（假设有2个线程，第一个线程加锁后，第二个线程将会阻塞在LOCK代码行，之后第一个线程将数据加入缓存后，解锁；此后第二个线程可以LOCK成功，进入临界区，然后执行查询缓存，就可以查询到线程一加入的缓存了）



---



## 1.3. 缓存雪崩

**缓存雪崩**：Redis服务器宕机 or 缓存在同一个时刻大面积失效，导致请求全部打到数据库上，造成数据库挂掉（Too many connect）。

**避免出现缓存雪崩**

① 为了防止“Redis服务器宕机”导致缓存雪崩，一般采用“搭建高可用集群”

② 大部分数据“同时失效”，采用“设置不同的过期时间”，防止同一时间大量数据过期现象发生

③ 设置热点数据永远不过期

**已经出现缓存雪崩**

假设已经出现缓存雪崩，那么，没有其他解决办法！只能进行“熔断”、“降级”、“限流”

- “熔断”，一旦发现当前服务的请求失败率达到预设的值，就拒绝随后该服务的所有请求。
- “限流”，当经过一段时间后，会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求，这就是所谓的“限流”。
- “降级”，而向那些被拒绝的请求直接返回一个预设结果，被称为“降级”

## 



----



# 2. 缓存一致性问题

经常会有人问，缓存会出现一致性问题，怎么样解决呢？当数据发生变更时，是先更新缓存再更新数据库，还是先更新数据库再更新缓存？:slightly_smiling_face:在这里，先给个结论：这种问法就有问题，即使你先更新谁都错，都不能保证缓存一致性。



### 2.1. 缓存不一致场景

下面的场景介绍都是高并发场景下的。

#### 2.1.1. 先更新缓存，再更新数据库

显然是不行呀，缓存更新成功了，但是更新数据库却失败了，那么，每次访问数据都先访问缓存中错误的数据！

#### 2.1.2. 先更新数据库，再更新缓存

**case1**：更新完数据库（更新成功），再更新缓存（更新失败，导致缓存中的数据是旧值）

[先更新数据库，再更新缓存_1](https://github.com/gEricy/knownledge/blob/master/A_%E6%95%B0%E6%8D%AE%E5%BA%93_SQL_Redis/%E5%8E%9F%E7%90%86%E5%9B%BE/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98_1.png)

**case2**：多线程的顺序问题。

[先更新数据库，再更新缓存_2](https://github.com/gEricy/knownledge/blob/master/A_%E6%95%B0%E6%8D%AE%E5%BA%93_SQL_Redis/%E5%8E%9F%E7%90%86%E5%9B%BE/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98_2.png)

- 原因分析：线程A、B都更新同一个字段ID。执行过程：线程A先更新数据库ID=1，然后发了一个更新缓存ID=1的操作，但是由于网络原因，更新缓存的操作卡住了。之后线程B更新数据库ID=2，且更新成功，然后线程B更新缓存成功ID=2。此后，之前卡住的线程A的更新缓存ID=1操作执行成功。

结束时，数据库/缓存中ID的值分别是ID=2、ID=1，出现不一致！

- 解决方案1（错误）：<font color=red>更新时，① 先删除缓存，② 再修改数据库。 </font>

  [先删除缓存，再更新数据库](https://github.com/gEricy/knownledge/blob/master/A_%E6%95%B0%E6%8D%AE%E5%BA%93_SQL_Redis/%E5%8E%9F%E7%90%86%E5%9B%BE/%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93.png)

  - 如果第②步数据库修改失败了，那么数据库中是旧数据，因为删除了缓存，所以缓存是空的。当读数据时候（缓存是空的），会去数据库中读取数据，这样并不会出现不一致性问题。

上面的解决方案看似很完美，但是实际上它还有问题！:smirk:真是靠了… …



1. 数据发生了变更，先删除缓存，然后去修改数据库，此时，还没修改数据库。
2. 但是一个读请求过来：将先去读缓存，发现缓存空了，就去查询数据库。会查到了未修改的数据库旧值，*将旧数据放到了缓存中。*
3. 随后，修改数据库操作完成，*数据库中的内容被更新为新值了。*

显然，数据库值是新的，缓存值是旧的，发生了不一致。

