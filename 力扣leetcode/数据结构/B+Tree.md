多路查找树，用在内存读取外存的场景下，可以减少磁盘IO次数，因为在高阶情况下，树不用很高就可以标识很大的数据量。

打个比方，以2-3树为例，树高为3的时候，一棵2-3树可以保存2+3x2+3x2x2=20个key；若当B树的阶数达到1001阶，即一个节点可以放1000个key，然后树高还是3，即 1000+1000x1001+1000x1001x1000 ，零头不算了，即至少可以放10个亿的key，此时只要让根节点读取到内存中，把子节点及子孙节点持久化到硬盘中，那么在这棵树上，寻找某一个key至多需要2次硬盘的读取即可。

### B树

对于一棵m阶的B树，定义如下

- 每个节点最多有m-1个key
- 根节点至少有1个key
- 非根节点至少有math.ceil(m/2)-1个key
- 每个节点中的key都有序（从小到大）
- 所有叶子节点都位于同一层



### B+树

:question:: 有了B树为什么还要使用B+树？

答：因为B树具有两个缺点。① 范围查询不友好 ② B树的每个中间节点都存放（key，value），在读取数据时，要将其读入内存，占用较多的空间。



对于一棵m阶的B+树，定义如下：

- 每个节点最多有m个key
- 非叶子节点仅仅具有索引作用，不存放数据；数据都保存在叶子节点上
- 叶子节点构成有序链表，可以按照key排序遍历全部记录



分裂：当节点key个数大于m时，要进行分裂

合并：当节点key个数小于math.ceil(m/2)-1，要进行合并

### 优缺点对比 / 使用场景

B树：每个节点上都存放数据，占用更多的内存，查询经过树的高度比B+数短 ==> MongoDB

B+数：① 中间节点不存放数据，数据全部放在叶子节点 ==>（1. 占用内存少 2. 查询效率更稳定，不受内存影响而波动）② 叶子节点连成链表 ==> 便于区间查询（适用于MySQL的Innodb引擎
