### 虚函数与内联

1. 虚函数可以声明为内联，编译成功
2. 但是内不内联，不由inline关键字决定，而是由编译器决定（编译器觉得适合inline那就内联咯，不适合就不内联咯）

结论：<u>虚函数要多态的时不内联；不多态的时，可以内联</u>

---


### 构造函数能不能使用virtual修饰

> 不能，会编译错误
>
> - 不能,因为构造函数用来创建一个新的对象，而虚函数的运行的动态绑定，它是建立在创建完对象的基础上。
> - 在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数

---



### 虚函数表属于 类？ 对象？

- 虚函数表属于**类**
  - 父类、子类都有自己的虚函数表，所有的对象都会去访问该类的共有的虚函数表

### 析构函数能否抛出异常？

- 不能（侯捷大师明确说明，析构函数不能抛出异常）
- 原因见下
  - 如果析构函数抛出异常，异常点之后的代码段将不会执行（可能会造成不能释放资源）
  - 但是如果你要释放资源，举个例子推翻这种做法的危害性
    - 程序员，在异常时，释放vector中的成员
      - 假设vec[0]抛出异常，会去释放vec
      - 假设vec[1]抛出异常，也会去释放vec
      - 这样会造成2次释放vec，出core

- 若析构函数抛出异常，正确的做法
  - 捕获该异常，吞下它们or结束程序
  - 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通的函数（而非在析构函数中）执行该操作

- 补充: :slightly_smiling_face:C++建议，构造函数一定要抛出异常
  - 如果不抛出，异常可能会存在很久，产生更加难查的BUG

----



### STL内存池

STL内存分配，包含一级分配器、二级分配器

- 一级分配器：采用malloc分配内存（>128K时，采用一级分配器）
  - brk
  - mmap
- 二级分配器：采用内存池（8k,16k,…,128k数组、战备池、20倍数分配）



----



### [操作系统之Slab伙伴算法](https://blog.csdn.net/csdn_kou/article/details/82355452)

操作系统使用slab算法，进行内存管理，它的一大优势是能够完全避免**外部碎片（页面）**的产生。

**分配原理**：把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。对1024 个页框的最大请求对应着 4MB 大小的连续RAM 块。每一块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16个页框的块，其起始地址是 16 * 2^12 （2^12 = 4096，这是一个常规页的大小）的倍数。

简而言之，就是在分配内存时，首先从空闲的内存中搜索比申请的内存大的最小的内存块。如果这样的内存块存在，则将这块内存标记为“已用”，同时将该内存分配给应用程序。如果这样的内存不存在，则操作系统将寻找更大块的空闲内存，然后将这块内存平分成两部分，一部分返回给程序使用，另一部分作为空闲的内存块等待下一次被分配。

**释放原理**：以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。内核试图把大小为 b 的一对空闲伙伴块合并为一个大小为 2b 的单独块。（该算法是迭代的，如果它成功合并所释放的块，它会试图合并 2b 的块，以再次试图形成更大的块）

两个块满足伙伴的条件：①两个块具有相同的大小，记作 b；②它们的物理地址是连续的；③第一块的第一个页框的物理地址是 2 * b * 2^12 的倍数


---

### i++为什么线程不安全

i++本质上分为3个步骤，这3步不是一个原子操作

> ① 从内存中读取 i 的值，保存到寄存器 ： eax = 内存i的值
>
> ② 寄存器的值++                                      ： eax++
>
> ③ 将寄存器的值，写回到内存中的 i      ： 内存i的值 = eax

两个线程同时执行，在执行上面3个步骤的时候，可能会由于线程抢占而切走，可能会导致某个被修改的值丢失

---

static成员函数与this

> 对于非static成员函数，编译器会传入一个“隐藏”的参数this
>
> 而，static成员函数，没有该“隐藏”的this参数

---



### const, 常成员函数

我们知道，成员函数的第一个参数是this指针，而const成员函数，实际上是在普通成员函数的基础上，又添加了一个const修饰，起到的作用是，该this指针指向的内容不能被修改

```c++
class A{
	void func1() {}       // 普通的成员函数， T* const --> 表示this指针本身不能被修改
    					  //                                 即不能this=obj
    void func2() const {} // const的成员函数 const T const* --> 表示this指针本身不能修改
    					  //							this指针指向的内容也不能被修改
}
```

### 函数重载/函数隐藏/函数覆盖

> 函数重载（静态绑定）
>
> > 作用域相同
> >
> > 函数名相同、形参列表（个数/类型/顺序）不同
> >
> > 注意：函数重载不考虑返回值的不同
>
> 函数隐藏
>
> > 作用域不同（如，派生类的函数隐藏）
> >
> > 函数名相同
> >
> > 形参和返回值不考虑
>
> 函数覆盖
>
> > virtual函数
> >
> > 作用域不同（必须在继承关系下的基类/子类）
> >
> > 形参列表（个数/类型/顺序）必须相同（子类可以不写virtual关键字）

---

### [虚表指针](https://www.pianshen.com/article/96031512059/)

- 虚函数表（属于类）

  > - 拥有虚函数的类会有一个虚表
  >
  > - 虚函数表通常存放在全局数据和静态数据区，这样类的所有对象都可以共享同一个唯一的虚函数表（可以简单的理解为类的静态成员）

- 虚函数指针（属于每个对象）

  > 和虚表不同，
  >
  > - 虚表是类的共有成员，它不属于某个对象
  > - 而虚函数指针
  >   - 每个类对象都有自己的虚函数指针，它指向一个共同的虚函数表
  >   - 类对象的虚函数指针，处于该类内存布局的最前面

- 虚表指针什么时候被赋值？

  > 我们都知道，类的对象是通过构造函数进行初始化的，但是我们从来没有在构造函数中初始化虚表指针
  >
  > - 虚表指针在 **执行构造函数体之前** 进行初始化的

  下面，我们重新理解下构造函数的过程

  > 进入到构造函数体之间，
  >
  > - 如果存在虚函数，虚表指针就会被初始化
  > - 如果存在构造函数的初始化列表，初始化列表就会执行
  >
  > 进入到构造函数体内
  >
  > - 执行构造函数



### 虚函数表

#### 虚函数表大小的确定

> 由编译器在编译期间确定
>
> 在运行时的内存中没有个数的表示
>
> 并不是以00结尾

#### 虚函数的调用方式

> - 直接调用
>
>   > 根据函数名称，直接调用函数（编译器在编译时候就确定了）
>   >
>   > - 普通的函数调用
>   > - 对象的普通成员函数的调用
>   > - 对象的虚函数的调用
>
> - 间接调用（虚调用）（动态绑定）
>
>   > 用法：父类的指针/引用指向子类的对象，调用虚函数
>   >
>   > 通过查虚函数表，在运行期间确定调用谁，实现动态绑定

----

### （单继承）虚函数表的布局

> 父类的虚函数顺序，决定了虚函数表中虚函数的顺序，进而决定了子类的虚函数顺序
>
> 子类会继承父类的虚函数表（即父类的虚函数表中有多少虚函数，子类一定就有多少个虚函数）
>
> > 没重写，就继承：子类没有重写的虚函数，会直接继承
> >
> > 有重写，就覆盖：子类重写了的虚函数，则会在子类自己的虚函数表中覆盖对应位置的函数
>
> 如果子类新增了父类没有的虚函数，会在虚函数表的后面，添加该虚函数

---

### （多继承）虚函数表的布局

多继承，虚函数表怎么画？





---

### C++函数栈的最大值

> 默认是1M，不过可以调整



### 隐式类型转换

> 内置类型
>
> > 低精度转换为高精度会进行隐式类型转换，且不存在安全问题
> >
> > - 反之，会存在丢失精度的问题（原因是，内存不能存放和表示这么多的数据）
>
> 隐式转换构造函数
>
> > 可以通过explict关键字，拒绝生成这种对象

------



### 常量

C++是怎么定义常量的？常量存放在内存中的那个区域？

> 常量在C++里的定义就是一个top-level const加上对象类型，常量定义时必须进行初始化

> 局部常量，存放在栈中
>
> 全局常量，存放在全局/静态存储区
>
> 字面值常量，存放在常量存储区

一个类的成员函数，同名，一个定义为const，另一个不定义为const，会有问题么？

```c++
class A{
	void f();        // --> T* const 修饰的指针this不能被修改
    void f() const;  // --> const T* const
}
```

> 不会，因为const也是参数限定符，这样实现的效果是函数重载
>
> - 如果从本质上谈起，实际上，非const函数/const函数，对于函数的第一个参数（this指针），它们的类型是不同的，因此它实际上符合重载的性质
>
> ------
>
> 补充
>
> > const修饰的变量，必须要通过【成员初始化列表】进行初始化
> >
> > - 必须要通过【成员初始化列表】进行初始化的成员变量包括：
> >
> >   > const
> >   >
> >   > 引用
> >   >
> >   > 一个类，它不能通过默认参数的构造函数进行初始化（要自己填上参数，进行初始化）

### const / volatile

#### const 可读的假常量

> 在现在C编译器中，修改const全局变量将导致程序崩溃
>
> 在C++中，const修饰的变量不是一个真的常量，它可以被修改（它只是告诉编译器该变量不能出现在赋值符号的左边），在C++中，表示的含义更多是**“可读”**

#### volatile随时可能发生变化的

> volatile强制编译器减少优化，必须每次从内存中取值

该关键字，可以防止扁你其对某个变量进行优化，每次去读取变量的值，总是重新从它所处的`内存`中读取（而不去读寄存器）。

- 编译器优化，会导致某个变量的值存入寄存器，当读取数据时，先去读取寄存器的值
- 但是，如果该值已经被修改，寄存器的值却由于优化没有发生改变，就会发生错误呀。

####  const和volatile一起用么？

结论：const和volatile可以一起使用,const表示该变量是“只读”，而不是常量

> 例如: 
>
> 如果假定0x30是仅由外部条件改变的端口值,
>
> 那么可如下定义:
>
> ​                const volatile unsigned char * port = 0x30;
>
> 这里的const其实表达的是只读, 而不是常量。

------



### vector的clear()函数

> 只会更改size，不会更改capacity
>
> - 将会清空vec中的所有元素，但是capacity会保留

vector为什么2倍扩容？ 

> 算法导论里的平摊分析

---

### debug和release区别

最近写代码过程中，发现 Debug 下运行正常，Release 下就会出现问题，百思不得其解，而Release下又无法进行调试，于是只能采用printf方式逐步定位到问题所在处，才发现原来是给定的一个数组未初始化，导致后面处理异常。网上查找了些资料，在这 罗列汇总下，做为备忘～ 

> Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。
>
> Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。 

- 变量

  > debug是将每个字节位都赋成0xcc
  >
  > 而release的赋值近似于随机

- release模式下不出错，但debug模式下报错

  > 这种情况下大多也是因为代码书写不正确引起的，查看MFC的源码，可以发现好多ASSERT的语句(断言)，这个宏只是在debug模式下才有效，那么就清楚了。
  >
  > release版不报错是忽略了错误而不是没有错误，这可能存在很大的隐患，因为是Debug模式下，比较方便调试，好好的检查自己的代码，再此，就不多说了。 

---

### 栈帧

栈中的数据都是以栈帧（Stack Frame）的格式存在

> 栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法 (Method) 和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，
>
> A方法又调用了 B 方法，于是产生栈帧 F2 也被压入栈，B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，
>
> ……执行完毕后，先弹出 F3 栈帧，再弹出 F2 栈帧，再弹出 F1 栈帧……

> 每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

---

### [socket发送数据过快会导致什么问题](https://www.cnblogs.com/liaokang/p/6003334.html)

1. 发送频率过高导致丢包

   > 很多人会不理解发送速度过快为什么会产生丢包，原因就是UDP的SendTo不会造成线程阻塞，也就是说，UDP的SentTo不会像TCP中的SendTo那样，直到数据完全发送才会return回调用函数，它不保证当执行下一条语句时数据是否被发送。（SendTo方法是异步的）这样，如果要发送的数据过多或者过大，那么在缓冲区满的那个瞬间要发送的报文就很有可能被丢失。至于对“过快”的解释，作者这样说：“A few packets a second are not an issue; hundreds or thousands may be an issue.”（一秒钟几个数据包不算什么，但是一秒钟成百上千的数据包就不好办了）。

2. 发送方丢包

   > 内部缓冲区（internal buffers）已满，并且发送速度过快（即发送两个报文之间的间隔过短）；
   >
   > > 但是更让人郁闷的事情出现了。无论是网上资料，还是询问同事，与tcp不同，发送这一块没有缓存区啊。
   > >
   > > 问题的，已经设置SO_SNDBUF为64M，修改系统值为128M，设置后获取到的SO_SNDBUF为128M。
   > >
   > > 现在就是在此种情况下发送丢包，128M是什么概念啊，所以基本可以排除这一块的问题。
   > >
   > > 通过命令watch netstat -s，可以明确的看出 Ip 项下的 outgoing packets dropped 持续增长，也就意味着确实是发送丢包。
   > >
   > > 然后就通过outgoing packets dropped ，sendto频率过快等等关键词开始查资料，结果让人蓝瘦香菇啊
   > >
   > > 阴差阳错的情况下，查到了 IOCTLS

结论

> sendto过快导致发送丢包，是因为发送队列满了，如果说缓存区，估计大部分人都将误解。
>
> 至于接收方因为突发率导致接收丢包的问题，那么就要在发送方进行发送平滑进行解决。



---

### 什么是指针？

开放性问题一个小小的

要明白什么是指针，必须先要弄清楚数据在内存中是如何存储的，又是如何被读取的。

> 如果在程序中定义了一个变量，在对程序进行编译时，系统就会为这个变量分配内存单元。
>
> 指针可以理解为一个地址，它指向内存单元



----

### 在构造函数期间泄漏this指针的危害

> 当一个类正在构造时在构造函数中将this泄露给了其它对象，这在单线程串行执行情况下可能没有什么问题，但是在多线程下那么问题就比较大了。
>
> 比如，多线程环境下，
>
> ​         线程A构造对象时，将指针泄露给线程B，但是B在A构造对象期间，更改了A中的指针成员，可能会引发程序崩溃。


#### 友元函数

① 优缺点

（优点）提供了一种数据共享的机制 ，提高程序的运行效率，使其他函数直接访问某个类的私有变量

（缺点）破坏了类的封装隐藏

② 使用场景

1. 运算符重载的某些场合需要使用友元

   `friend ostream& operator<< (ostream& cout,const MGraph& G);  `

2. 两个类需要数据共享的时候

③ 声明：

1. friend 返回值类型 函数名(形参)
2. 放在类的private/public都没有任何区别

④ 友元函数的参数？ ==> 因为友元函数没有this指针，所以，参数具有以下3种情况

1. 要访问`类的非static成员`时，**需要**对象做参数
2. 要访问`类的static成员`或`全局变量`时，不需要对象做参数
3. 如果做参数的对象是`·全局对象`，则不需要对象做参数

⑤ 友元函数的调用 ==> 可以直接调用友元函数，不需要通过对象or指针
