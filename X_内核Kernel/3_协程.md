

### 寄存器

寄存器是CPU中央处理器的组成部分

- 它是硬件设备（有限存储容量的高速存储部件），用于暂存指令地址、数据
- 主要用来存放指令集、地址、数据信息

---

### 栈帧

栈帧叫做过程活动记录，是编译器用来实现**函数调用**的一种数据结构

栈帧就是函数执行的环境：函数参数、函数局部变量、函数执行完成后返回到哪里… …

栈从高地址向低地址延申

> 1. 每个函数调用时，都会拥有自己独立的栈帧
>
> 2. 这个栈帧中维持着所有需要的各种信息
>
> 3. 有两个寄存器指针ebp/esp
>
>    > 寄存器bp指向栈帧底部（高地址），sp指向当前栈帧顶部（低地址）

---

- 内核/用户

  - 虚拟地址空间，被划分为1G内核空间+3G用户空间

  - 操作系统运行在内核空间，用户程序运行在用户空间

  - 内核空间由所有进程的地址空间共享，但是为了保证安全，用户程序不能直接访问内核空间

  - **操作系统保存的 进程控制信息PCB 存放在内核空间**

    > 进程控制信息：页目录、进程ID、状态、打开文件句柄表等等

  - 线程就是进程的执行体，它要有指定的执行入口，通常会是某个函数的指令入口

    > - 线程执行时，要使用从进程虚拟地址空间中分配的栈空间来存储数据，这被称为【线程栈】
    >
    > - 在创建线程时，操作系统会使用用户空间和内核空间分配的两个栈，就是通常所说的用户栈、内核栈
    > - 线程切换到内核态执行时，会使用内核栈（为了是不允许用户代码对其修改，以保证安全）
    > - 操作系统会记录线程控制信息TCB（如：执行入口、线程栈、线程ID等等）
    > - 在PCB中可以找到进程拥有的TCB列表，PCB ==> TCB ==> TCB ==> TCB … …

  - 而Linux中只使用了一个task_struct结构体

    > 进程在创建子进程时会指定它和自己使用同一套地址空间和句柄表等资源

---

### 进程/线程

- [线程切换的过程](https://www.bilibili.com/video/BV1yJ411A7py/?spm_id_from=autoNext)

  1. 要执行进程中的线程**a1**中的函数调用时，就会在**栈帧**插入函数**调用栈**，此时，**bp/sp**分别指向当前栈帧的**栈帧底部/栈帧顶部**，**将bp/sp记录在寄存器中**

     > 而虚拟内存分配、文件操作、网络读写等很多功能都是由操作系统来实现，操作系统提供了一些列接口，即系统调用，给上层用户程序调用。 所以，线程免不了要调用操作系统提供的系统调用

     > CPU有一个**特权标记**，用于记录当前程序执行在用户态还是内核态。只有标记为内核态时，才可以访问内核空间

  2. **系统调用过程一次**

     而目前线程**a1**处在用户态，还不能访问内核空间。所以，系统调用发生时就得切换到内核态，会使用线程的内核栈，执行内核空间的系统调用。这被称为从用户态切换到内核态。

     > 系统调用是通过**软中断**的方式触发的，所谓软中断，简单来讲，就是通过 **指令** 来模拟中断

     > 1. 操作系统会根据CPU要求，在内存中存放一张**中断向量表**，用来把各个**中断编号映射到相应的处理程序**（如：0x80中断编号，对应的处理程序是“系统调用派发”）
     > 2. 所以，操作系统又实现了一张**系统调用表**：用来通过**系统调用编号**，找到**对应的系统函数入口**。 
     > 3. 所以，用户程序这里，会把系统调用编号存入特定寄存器中，通过寄存器或用户栈来传递其他所需参数
     > 4. 然后用0x80来触发系统调用中断。而，硬件层面，CPU有一个**中断控制器**，它负责接受中断信号，切换到内核态，保存用户态执行现场
     > 5. 然后，去中断向量表中查询0x80对应的系统调用派发程序入口。而系统调用的派发程序会根据指定的系统调用编号，再去系统调用表中查找对应的函数入口。之后，会将bp/sp/ip指向内核栈中的栈帧/执行指令入口，此时，才真正的陷入内核态，执行ip指向的指令
     > 6. 执行完成后，恢复之前在寄存器中保存的用户态执行现场，继续执行后面的指令
     > 7. 这样，就完成了一次系统调用。

  3. **线程切换**

     > CPU的执行权被划分为不同的时间片，只有获得CPU时间片的程序，才能执行

     > 一个线程执行的时间片用完时，CPU硬件会触发一次时钟中断。对应的处理程序是从已经就绪的线程队列中选出一个来执行，此时，会发生线程的切换

     > bp/sp/指令指针ip 寄存器

     例如，接下来，介绍下面两种场景

     ① 在同一个进程中，要从线程a1切换到线程a2

     > 1. 首先，保存线程a1的执行现场，即将（bp/sp）保存到寄存器中
     > 2. 之后，将bp/sp/ip指针指向线程a2，执行线程a2函数
     >
     > 这样，一次同进程间的线程切换就完成了
     >
     > 1. 等到线程a1再次获得时间片时
     > 2. 会根据之前寄存器中保存的bp/sp，恢复到切换前的执行现场，继续完成它的任务

     ② 在不同进程中，要从进程A1的线程a1切换到进程B2的线程a2

     > 那么除了线程切换，还要切换进程
     >
     > CPU这里保存的页目录地址要切换到进程B，所以，进程切换与线程切换的区别是：进程切换会导致地址空间等进程资源发生变化，会导致TLB缓存失效，代价相应很大！

  上面介绍的进程线程控制信息，都是由操作系统来记录的，它替我们实现调度。

  ---

  ### 协程

  协同式，与上面抢占式调度不同，它是在应用层由用户自己调度！更加高效，不存在用户态和内核态的切换，不存在锁竞争等问题，效率十分高！

  

  协程是在线程中创建的几个执行体，每个执行体都有自己的执行入口，在【用户空间】申请一些内存给她们用作执行栈，那么，用户就可以根据自己的需求在用户态实现这几个执行体之间的来回切换和调度。

  > 为了实现这些执行体的切换，线程也需要记录它们的控制信息，包括ID、栈的位置、执行入口地址、执行现场等等
  >
  > 线程可以选择一个执行体执行，此时，CPU中，指令指针就会指向那个执行体的执行入口，栈基和栈指针也会指向线程给它们分配的执行栈，要切换执行体时，需要先保存当前执行体的执行现场，然后，切换到另一个执行体。通过同样的方式，可以恢复到之前的执行体，这样就可以从上次中断的位置继续执行。
  >
  > ---
  >
  > 这些由线程创建的执行体，就是所谓的“协程”。
  >
  > 整个过程都是发生在用户空间，所以只能给协程分配【用户栈】，而操作系统对协程一无所知，所以，协程又被称为“用户态线程”。
  >
  > 这样，就通过协程实现了既轻量又灵活的调度。
  >
  > ---
  >
  > 协程风平浪静了很多年，直到高并发称为主流趋势，瞬间抵达的海量请求让多进程、模式下内存资源捉襟见拙，让多线程模式下CPU在内核态/用户态之间切换两头忙，却依然疲于应对。协程这种轻量快捷的用户态调度模型受到广泛的关注。**而真正让协程大放异彩的是它在IO多路复用中的应用**，二者的结合，助力形成炙手可热的高并发解决方案！
  >
  > ---

  ### [协程和IO多路复用更配哦~](https://www.bilibili.com/video/BV1a5411b7aZ/?spm_id_from=autoNext)

  写在最前：文件描述符表

  > 我们知道，OS记录的进程控制信息，可以找到文件描述符表。进程打开的文件、创建的socket等，都会记录在这张表里。socket的所有操作都有OS来提供，也就是要通过系统调用来完成，每创建一个socket，就会在打开的文件描述符表中对应增加一条记录，而返回给应用程序的只有一个socket描述符，用于识别不同的socket。

  > 而且，每次创建socket时，操作系统都会为它分配一个读缓冲区和一个写缓冲区，（读写缓冲区都存在于内核空间）
  >
  > 要获得数据，就要从内核中的读缓冲区将数据拷贝到用户空间的接收缓冲区
  >
  > 要发送数据，就要把用户空间的发送缓冲区数据的数据拷贝到内核中的写缓冲区
  >
  > ---
  >
  > 所以，问题出现了
  >
  > 1. 用户想要读取数据时，内核中的读缓冲区中可能没数据
  > 2. 用户想要发送数据时，内核中的写缓冲区可能没空间
  >
  > ---
  >
  > 解决方案，就是采用IO多路复用
  >
  > > 由OS提供支持，把需要等待的socket加入到监听集合，这样就可以通过一次系统调用，同时监听多个socket，有socket就绪了，就可以逐个处理了。
  >
  > select缺点
  >
  > > 需要将fd_set在用户态和内核态来回拷贝
  > >
  > > 每次都要遍历所有集合，查询哪个fd就绪
  >
  > epoll可以解决上面的问题，但是，也并不是没问题
  >
  > > 比如，一个fd可读了，但是，调用read只读了半条请求，也就是说，需要再次等待这个fd可读。
  > >
  > > ```c++
  > > if(没读完) {
  > > 	保存现场 // 在继续处理下一个fd之前，需要记录下这个fd的处理状态
  > > 	等待可读
  > > }
  > > ```
  > >
  > > 在继续处理下一个fd之前，需要记录下这个fd的处理状态（即，保存现场，等待可读）。下一次这个fd可读时，也需要恢复上次保存的现场，才好继续执行。
  > >
  > > ```c++
  > > 恢复现场
  > > 接着读
  > > if(没读完) {
  > > 	保存现场 // 在继续处理下一个fd之前，需要记录下这个fd的处理状态
  > > 	等待可读
  > > }
  > > ```
  > >
  > > 也就是说，在IO多路复用中实现业务逻辑时，我们需要随着事件的等待和就绪，而频繁的保存和恢复现场，这并不符合常规的开发习惯。如果业务逻辑比较简单还好，若是较为复杂的业务场景，就很悲剧了。
  > >
  > > ---
  > >
  > > 既然，业务处理过程中，要等待事件时，需要保存现场并切换到下一个就绪的fd，而，事件就绪时，又需要恢复现场继续处理，那岂不是很适用于协程！
  > >
  > > 在IO多路复用这里，事件循环依然存在，依然要在for循环终逐个处理就绪的fd，但处理过程却不是围绕具体业务，而是**面向协程调度**。
  > >
  > > >  如果是用于监听端口的fd就绪了，就建立连接创建一个新的fd，交给一个协程来负责。协程执行入口就指向业务处理函数入口，
  > > >
  > > > ```c++
  > > > if(不可读) {
  > > > 	epoll_clt(,, ADD) // 注册IO事件
  > > > 	yield()
  > > > }
  > > > read(...)
  > > > ...
  > > > ```
  > > >
  > > > 可以把read/write/connect…可能发生等待的函数采用HOOK机制包装一下，在其中实现IO事件的注册（将事件托管给epoll监听）与主动让出（yield），当epoll检测到事件到来时，将切回resume该协程，继续执行下面的系统read函数读取数据。
  > > >
  > > > ----
  > > >
  > > > 这样就在业务层面，就可以使用这些包装函数，按照常规的顺序编程方式来实现业务逻辑了，这些包装函数，在需要等待时就注册IO事件，然后让出协程。在IO事件就绪时，又会切回协程继续处理。
  > > >
  > > > ---
  > > >
  > > > 这样，我们在实现业务逻辑时就完全不用关心保存与恢复现场的问题了！协程和IO多路复用之间的合作，不仅保留了IO多路复用的高并发性能，还解放了业务逻辑的实现。

#### [源码](https://github.com/fengyoulin/ef)

业务逻辑

框架层：封装事件循环、包装函数

IO多路复用：poll/epoll/kqueue

协程池：方便协程管理

协程：协程数据结构，核心功能

---
---
:atom_symbol::atom_symbol::atom_symbol:  协程切换原理

### 创建协程时

1. 创建协程控制块co，co里面包含 `协程栈指针、ctx`
2. 在 **堆上** 申请内存，作为协程栈

### co_resume 协程切换

1. coctx_make( &co->ctx, (coctx_pfn_t)CoRoutineFunc, co, 0 );
   
   - 将 [ 协程栈sp指针、(协程函数、协程参数) ] 保存到 ctx->regs[13/7/8/9]中 指针数组中
   
2. coctx_swap(&(src->ctx),&(dst->ctx) ); 采用汇编的方式，实现协程切换

   - 【store】
     - 将当前寄存器的值(sp指针/bp指针/参数/返回值/当前协程切换走的运行位置...)，压入协程栈(PUSH)，即：保存到ctx->regs[]数组指向的内存(协程栈的一个个区域)中
       ===> 当前协程栈保存完成，后期恢复时，重新加载该协程栈中的内容即可

   - 【load】

     - (POP) 弹出协程栈中保存的值

       1) regs[0]的值，保存到寄存器。regs[0]是之前协程切换走的运行位置

       2) 所有regs[]保存的值

     - 将上面弹出的regs[]指向的协程栈中的值，全部加载到寄存器，然后恢复之前的协程，继续运行
